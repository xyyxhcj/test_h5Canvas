<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>迷宫生成</title>
</head>
<body>
<canvas height="900" id="canvas1" style="background:white;" width="900"></canvas>
<script>
    // 定义坐标对象
    const Position = {
        x: 0,
        y: 0,
        // 坐标类型
        type: '',
        prePosition: Object
    };
    // 迷宫对象
    const MAZE_DATA = {
        // 迷宫数据
        arr: {},
        // 去除迷雾区域
        clearMist: [],
        // 开始坐标
        startX: 0,
        startY: 1,
        // 迷宫布局起点
        layoutBeginX: 1,
        layoutBeginY: 1,
        // 终点坐标
        exitX: Number,
        exitY: Number,
        height: Number,
        width: Number
    };

    function instance(width, height) {
        if (width % 2 === 0) {
            width--;
        }
        if (height % 2 === 0) {
            height--;
        }
        MAZE_DATA.width = width;
        MAZE_DATA.height = height;
        for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
                let type;
                if (i % 2 === 1 && j % 2 === 1) {
                    setType(MAZE_HISTORY, i, j, false);
                    type = CONFIG.default;
                } else {
                    type = CONFIG.wall;
                }
                setType(MAZE_DATA.arr, i, j, type);
            }
        }
        // 起点
        setType(MAZE_DATA.arr, MAZE_DATA.startX, MAZE_DATA.startY, CONFIG.default);
        setType(MAZE_HISTORY, MAZE_DATA.startX, MAZE_DATA.startY, false);
        // 终点
        MAZE_DATA.exitX = width - 1;
        MAZE_DATA.exitY = height - 2;
        setType(MAZE_DATA.arr, MAZE_DATA.exitX, MAZE_DATA.exitY, CONFIG.default);
        setType(MAZE_HISTORY, MAZE_DATA.exitX, MAZE_DATA.exitY, false);
        return MAZE_DATA;
    }

    // 向二维字典中添加数据
    function setType(dict, x, y, type) {
        let position = Object.create(Position);
        if (!dict[x]) {
            dict[x] = {};
        }
        position.x = x;
        position.y = y;
        position.type = type;
        dict[x][y] = position;
    }

    // 配置
    const CONFIG = {
        // 延迟
        delay: 500,
        // 坐标所占像素
        size: 6,
        // 墙标识
        wall: '#',
        // 标记空白的路
        empty: 0,
        // 标记路径
        road: 1,
        // 标记路线
        path: 2,
        default: -1
    };
    // 记录走过的坐标
    const HISTORY = {};
    const MAZE_HISTORY = {};
    // 定义四个方向下一步的计算方式:上右下左
    const NEXT = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    // 保存图状态
    const STATUS_ARR = [];

    // 画迷宫
    function drawMaze(context, arr) {
        // 清空画布
        context.clearRect(0, 0, 1500, 1500);
        for (let x in arr) {
            for (let y in arr[x]) {
                if (arr[x][y].type === CONFIG.wall) {
                    // 墙
                    context.fillStyle = 'blue';
                    context.fillRect(x * CONFIG.size, y * CONFIG.size, CONFIG.size, CONFIG.size);
                }
            }
        }
    }

    function pushStatus(arr) {
        STATUS_ARR.push(JSON.parse(JSON.stringify(arr)));
    }

    function addQueue(queue, x, y) {
        let position = Object.create(Position);
        position.x = x;
        position.y = y;
        queue.push({maze: MAZE_DATA.arr, position: position});
        return position;
    }

    function run(id) {
        let canvas = document.getElementById(id);
        if (!canvas) {
            return false;
        }
        let context = canvas.getContext('2d');
        // 迷宫初始化
        instance(10, 10);
        let maze = MAZE_DATA.arr;
        drawMaze(context, maze);
        // 存储待探索区域
        let queue = [];
        // 放入起始坐标
        let position = addQueue(queue, MAZE_DATA.layoutBeginX, MAZE_DATA.layoutBeginY);
        while (queue.length > 0) {
            let pop = queue.pop();
            maze = pop.maze;
            position = pop.position;
            // 标记已探索
            setType(MAZE_HISTORY, position.x, position.y, true);
            // setType(maze, position.x, position.y, CONFIG.empty);
            if (position.prePosition) {
                // 凿开迷宫中的墙壁
                let x = (position.x + position.prePosition.x) >> 1;
                let y = (position.y + position.prePosition.y) >> 1;
                setType(maze, x, y, CONFIG.empty);
                // setType(MAZE_HISTORY, x, y, true);
                pushStatus(maze);
            }
            // 向四个方向各走2步,连线
            for (let i = 0; i < NEXT.length; i++) {
                let goX = parseInt(position.x + NEXT[i][0] * 2);
                let goY = parseInt(position.y + NEXT[i][1] * 2);
                console.log(goX + '_' + goY);
                // console.log(maze[goX][goY]);
                if (goX > 0 && goY > 0 && goX < MAZE_DATA.width && goY < MAZE_DATA.height && maze[goX][goY] !== undefined && maze[goX][goY].type === CONFIG.default && (!MAZE_HISTORY[goX][goY] || !MAZE_HISTORY[goX][goY].type)) {

                    // if (goX > 0 && goY > 0 && goX < MAZE_DATA.width && goY < MAZE_DATA.height && (!MAZE_HISTORY[goX][goY] || !MAZE_HISTORY[goX][goY].type) && maze[goX][goY].type === CONFIG.empty) {
                    // 加入待探索栈/队列
                    let nextPosition = addQueue(queue, goX, goY);
                    // 存储上一级坐标
                    nextPosition.prePosition = position;
                }
            }
        }
        let i = 0;
        console.log(STATUS_ARR);
        setInterval(() => {
            if (i < STATUS_ARR.length) {
                drawMaze(context, STATUS_ARR[i]);
                i++;
            }
        }, CONFIG.delay);
    }

    run('canvas1');
</script>
</body>
</html>